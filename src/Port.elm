-- This module was autogenerated using elm-port-schema. Do not manually edit
    

port module Port exposing (..)

import Dict
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode


port fromElm : Encode.Value -> Cmd msg


port toElm : (Decode.Value -> msg) -> Sub msg


send : FromElmMessage -> Cmd msg
send =
    fromElm << encodeFromElmMessage


recive : (Result Decode.Error ToElmMessage -> msg) -> Sub msg
recive f =
    toElm (f << Decode.decodeValue decodeToElmMessage)



-- types


type FromElmMessage
    = JsIncrement Int
    | JsDecrement Int


type alias ToElmMessage =
    Int



-- codecs


encodeFromElmMessage : FromElmMessage -> Encode.Value
encodeFromElmMessage v =
    case v of
        JsIncrement a0 ->
            encodeVariant "JsIncrement" [ Encode.int a0 ]

        JsDecrement a0 ->
            encodeVariant "JsDecrement" [ Encode.int a0 ]


decodeFromElmMessage : Decoder FromElmMessage
decodeFromElmMessage =
    decodeCustomType
        [ ( "JsIncrement"
          , Decode.map JsIncrement (Decode.int |> Decode.field "_0")
          )
        , ( "JsDecrement"
          , Decode.map JsDecrement (Decode.int |> Decode.field "_0")
          )
        ]


encodeToElmMessage : ToElmMessage -> Encode.Value
encodeToElmMessage =
    Encode.int


decodeToElmMessage : Decoder ToElmMessage
decodeToElmMessage =
    Decode.int



-- prelude


encodeUnit : () -> Encode.Value
encodeUnit _ =
    encodeVariant "()" []


decodeUnit : Decode.Decoder ()
decodeUnit =
    decodeCustomType [ ( "()", Decode.succeed () ) ]


encodeChar : Char -> Encode.Value
encodeChar c =
    Encode.string (String.fromChar c)


decodeChar : Decode.Decoder Char
decodeChar =
    Decode.andThen
        (\string ->
            case String.toList string of
                [ char ] ->
                    Decode.succeed char

                _ ->
                    Decode.fail
                        ("Expected string of length 1. Got "
                            ++ String.fromInt (String.length string)
                        )
        )
        Decode.string


encodeTuple : (a -> Encode.Value) -> (b -> Encode.Value) -> ( a, b ) -> Encode.Value
encodeTuple encoderA encoderB ( a, b ) =
    Encode.list identity
        [ encoderA a
        , encoderB b
        ]


decodeTuple : Decoder t1 -> Decoder t2 -> Decoder ( t1, t2 )
decodeTuple t1Decoder t2Decoder =
    Decode.map2 Tuple.pair
        (Decode.index 0 t1Decoder)
        (Decode.index 1 t2Decoder)


encodeTuple3 : (a -> Encode.Value) -> (b -> Encode.Value) -> (c -> Encode.Value) -> ( a, b, c ) -> Encode.Value
encodeTuple3 encoderA encoderB encoderC ( a, b, c ) =
    Encode.list identity
        [ encoderA a
        , encoderB b
        , encoderC c
        ]


decodeTuple3 : Decoder t1 -> Decoder t2 -> Decoder t3 -> Decoder ( t1, t2, t3 )
decodeTuple3 t1Decoder t2Decoder t3Decoder =
    Decode.map3 (\e1 e2 e3 -> ( e1, e2, e3 ))
        (Decode.index 0 t1Decoder)
        (Decode.index 1 t2Decoder)
        (Decode.index 3 t3Decoder)


encodeMaybe : (a -> Encode.Value) -> Maybe a -> Encode.Value
encodeMaybe innerEncoder m =
    case m of
        Just inner ->
            encodeVariant "Just" [ innerEncoder inner ]

        Nothing ->
            encodeVariant "Nothing" []


decodeMaybe : Decoder t -> Decoder (Maybe t)
decodeMaybe justDecoder =
    decodeCustomType
        [ ( "Just"
          , Decode.map Just
                (decodeVariantArg 0 justDecoder)
          )
        , ( "Nothing", Decode.succeed Nothing )
        ]


encodeResult : (x -> Encode.Value) -> (a -> Encode.Value) -> Result x a -> Encode.Value
encodeResult errEncoder okEncoder r =
    case r of
        Ok ok ->
            encodeVariant "Ok" [ okEncoder ok ]

        Err err ->
            encodeVariant "Err" [ errEncoder err ]


decodeResult : Decoder e -> Decoder t -> Decoder (Result e t)
decodeResult errorDecoder okDecoder =
    decodeCustomType
        [ ( "Ok"
          , Decode.map Ok (decodeVariantArg 0 okDecoder)
          )
        , ( "Err"
          , Decode.map Err (decodeVariantArg 0 errorDecoder)
          )
        ]


encodeRecord : List ( String, a -> Encode.Value ) -> a -> Encode.Value
encodeRecord fields record =
    Encode.object
        (List.map
            (\( fieldName, fieldEncoder ) -> ( fieldName, fieldEncoder record ))
            fields
        )


decodeRecordField : String -> Decoder a -> Decoder (a -> b) -> Decoder b
decodeRecordField fieldName fieldDecoder recordDecoder =
    Decode.andThen
        (\fieldValue -> Decode.map (\f -> f fieldValue) recordDecoder)
        (Decode.field fieldName fieldDecoder)


decodeCustomType : List ( String, Decoder a ) -> Decoder a
decodeCustomType decoders =
    Decode.andThen
        (\variant ->
            case Dict.get variant (Dict.fromList decoders) of
                Nothing ->
                    Decode.fail
                        ("Unexpected variant. Expected on of the following: "
                            ++ String.join ", " (List.map Tuple.first decoders)
                        )

                Just variantDecoder ->
                    variantDecoder
        )
        (Decode.field "variant" Decode.string)


encodeVariant : String -> List Encode.Value -> Encode.Value
encodeVariant variantName variantArgs =
    Encode.object
        ([ ( "variant", Encode.string variantName ) ]
            ++ List.indexedMap
                (\index variantArg ->
                    ( "_" ++ String.fromInt index, variantArg )
                )
                variantArgs
        )


decodeVariant : Decoder String
decodeVariant =
    Decode.field "variant" Decode.string


decodeVariantArg : Int -> Decoder a -> Decoder a
decodeVariantArg n =
    Decode.field ("_" ++ String.fromInt n)
